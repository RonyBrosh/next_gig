// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'splash_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$SplashEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() animateTitle,
    required TResult Function() animateSubtitle,
    required TResult Function() animateBody,
    required TResult Function() animateDiscoverButton,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? animateTitle,
    TResult Function()? animateSubtitle,
    TResult Function()? animateBody,
    TResult Function()? animateDiscoverButton,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? animateTitle,
    TResult Function()? animateSubtitle,
    TResult Function()? animateBody,
    TResult Function()? animateDiscoverButton,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnimateTitle value) animateTitle,
    required TResult Function(_AnimateSubtitle value) animateSubtitle,
    required TResult Function(_AnimateBody value) animateBody,
    required TResult Function(_AnimateDiscoverButton value)
        animateDiscoverButton,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_AnimateTitle value)? animateTitle,
    TResult Function(_AnimateSubtitle value)? animateSubtitle,
    TResult Function(_AnimateBody value)? animateBody,
    TResult Function(_AnimateDiscoverButton value)? animateDiscoverButton,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnimateTitle value)? animateTitle,
    TResult Function(_AnimateSubtitle value)? animateSubtitle,
    TResult Function(_AnimateBody value)? animateBody,
    TResult Function(_AnimateDiscoverButton value)? animateDiscoverButton,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SplashEventCopyWith<$Res> {
  factory $SplashEventCopyWith(
          SplashEvent value, $Res Function(SplashEvent) then) =
      _$SplashEventCopyWithImpl<$Res>;
}

/// @nodoc
class _$SplashEventCopyWithImpl<$Res> implements $SplashEventCopyWith<$Res> {
  _$SplashEventCopyWithImpl(this._value, this._then);

  final SplashEvent _value;
  // ignore: unused_field
  final $Res Function(SplashEvent) _then;
}

/// @nodoc
abstract class _$$_AnimateTitleCopyWith<$Res> {
  factory _$$_AnimateTitleCopyWith(
          _$_AnimateTitle value, $Res Function(_$_AnimateTitle) then) =
      __$$_AnimateTitleCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AnimateTitleCopyWithImpl<$Res>
    extends _$SplashEventCopyWithImpl<$Res>
    implements _$$_AnimateTitleCopyWith<$Res> {
  __$$_AnimateTitleCopyWithImpl(
      _$_AnimateTitle _value, $Res Function(_$_AnimateTitle) _then)
      : super(_value, (v) => _then(v as _$_AnimateTitle));

  @override
  _$_AnimateTitle get _value => super._value as _$_AnimateTitle;
}

/// @nodoc

class _$_AnimateTitle implements _AnimateTitle {
  const _$_AnimateTitle();

  @override
  String toString() {
    return 'SplashEvent.animateTitle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AnimateTitle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() animateTitle,
    required TResult Function() animateSubtitle,
    required TResult Function() animateBody,
    required TResult Function() animateDiscoverButton,
  }) {
    return animateTitle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? animateTitle,
    TResult Function()? animateSubtitle,
    TResult Function()? animateBody,
    TResult Function()? animateDiscoverButton,
  }) {
    return animateTitle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? animateTitle,
    TResult Function()? animateSubtitle,
    TResult Function()? animateBody,
    TResult Function()? animateDiscoverButton,
    required TResult orElse(),
  }) {
    if (animateTitle != null) {
      return animateTitle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnimateTitle value) animateTitle,
    required TResult Function(_AnimateSubtitle value) animateSubtitle,
    required TResult Function(_AnimateBody value) animateBody,
    required TResult Function(_AnimateDiscoverButton value)
        animateDiscoverButton,
  }) {
    return animateTitle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_AnimateTitle value)? animateTitle,
    TResult Function(_AnimateSubtitle value)? animateSubtitle,
    TResult Function(_AnimateBody value)? animateBody,
    TResult Function(_AnimateDiscoverButton value)? animateDiscoverButton,
  }) {
    return animateTitle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnimateTitle value)? animateTitle,
    TResult Function(_AnimateSubtitle value)? animateSubtitle,
    TResult Function(_AnimateBody value)? animateBody,
    TResult Function(_AnimateDiscoverButton value)? animateDiscoverButton,
    required TResult orElse(),
  }) {
    if (animateTitle != null) {
      return animateTitle(this);
    }
    return orElse();
  }
}

abstract class _AnimateTitle implements SplashEvent {
  const factory _AnimateTitle() = _$_AnimateTitle;
}

/// @nodoc
abstract class _$$_AnimateSubtitleCopyWith<$Res> {
  factory _$$_AnimateSubtitleCopyWith(
          _$_AnimateSubtitle value, $Res Function(_$_AnimateSubtitle) then) =
      __$$_AnimateSubtitleCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AnimateSubtitleCopyWithImpl<$Res>
    extends _$SplashEventCopyWithImpl<$Res>
    implements _$$_AnimateSubtitleCopyWith<$Res> {
  __$$_AnimateSubtitleCopyWithImpl(
      _$_AnimateSubtitle _value, $Res Function(_$_AnimateSubtitle) _then)
      : super(_value, (v) => _then(v as _$_AnimateSubtitle));

  @override
  _$_AnimateSubtitle get _value => super._value as _$_AnimateSubtitle;
}

/// @nodoc

class _$_AnimateSubtitle implements _AnimateSubtitle {
  const _$_AnimateSubtitle();

  @override
  String toString() {
    return 'SplashEvent.animateSubtitle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AnimateSubtitle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() animateTitle,
    required TResult Function() animateSubtitle,
    required TResult Function() animateBody,
    required TResult Function() animateDiscoverButton,
  }) {
    return animateSubtitle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? animateTitle,
    TResult Function()? animateSubtitle,
    TResult Function()? animateBody,
    TResult Function()? animateDiscoverButton,
  }) {
    return animateSubtitle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? animateTitle,
    TResult Function()? animateSubtitle,
    TResult Function()? animateBody,
    TResult Function()? animateDiscoverButton,
    required TResult orElse(),
  }) {
    if (animateSubtitle != null) {
      return animateSubtitle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnimateTitle value) animateTitle,
    required TResult Function(_AnimateSubtitle value) animateSubtitle,
    required TResult Function(_AnimateBody value) animateBody,
    required TResult Function(_AnimateDiscoverButton value)
        animateDiscoverButton,
  }) {
    return animateSubtitle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_AnimateTitle value)? animateTitle,
    TResult Function(_AnimateSubtitle value)? animateSubtitle,
    TResult Function(_AnimateBody value)? animateBody,
    TResult Function(_AnimateDiscoverButton value)? animateDiscoverButton,
  }) {
    return animateSubtitle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnimateTitle value)? animateTitle,
    TResult Function(_AnimateSubtitle value)? animateSubtitle,
    TResult Function(_AnimateBody value)? animateBody,
    TResult Function(_AnimateDiscoverButton value)? animateDiscoverButton,
    required TResult orElse(),
  }) {
    if (animateSubtitle != null) {
      return animateSubtitle(this);
    }
    return orElse();
  }
}

abstract class _AnimateSubtitle implements SplashEvent {
  const factory _AnimateSubtitle() = _$_AnimateSubtitle;
}

/// @nodoc
abstract class _$$_AnimateBodyCopyWith<$Res> {
  factory _$$_AnimateBodyCopyWith(
          _$_AnimateBody value, $Res Function(_$_AnimateBody) then) =
      __$$_AnimateBodyCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AnimateBodyCopyWithImpl<$Res> extends _$SplashEventCopyWithImpl<$Res>
    implements _$$_AnimateBodyCopyWith<$Res> {
  __$$_AnimateBodyCopyWithImpl(
      _$_AnimateBody _value, $Res Function(_$_AnimateBody) _then)
      : super(_value, (v) => _then(v as _$_AnimateBody));

  @override
  _$_AnimateBody get _value => super._value as _$_AnimateBody;
}

/// @nodoc

class _$_AnimateBody implements _AnimateBody {
  const _$_AnimateBody();

  @override
  String toString() {
    return 'SplashEvent.animateBody()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AnimateBody);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() animateTitle,
    required TResult Function() animateSubtitle,
    required TResult Function() animateBody,
    required TResult Function() animateDiscoverButton,
  }) {
    return animateBody();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? animateTitle,
    TResult Function()? animateSubtitle,
    TResult Function()? animateBody,
    TResult Function()? animateDiscoverButton,
  }) {
    return animateBody?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? animateTitle,
    TResult Function()? animateSubtitle,
    TResult Function()? animateBody,
    TResult Function()? animateDiscoverButton,
    required TResult orElse(),
  }) {
    if (animateBody != null) {
      return animateBody();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnimateTitle value) animateTitle,
    required TResult Function(_AnimateSubtitle value) animateSubtitle,
    required TResult Function(_AnimateBody value) animateBody,
    required TResult Function(_AnimateDiscoverButton value)
        animateDiscoverButton,
  }) {
    return animateBody(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_AnimateTitle value)? animateTitle,
    TResult Function(_AnimateSubtitle value)? animateSubtitle,
    TResult Function(_AnimateBody value)? animateBody,
    TResult Function(_AnimateDiscoverButton value)? animateDiscoverButton,
  }) {
    return animateBody?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnimateTitle value)? animateTitle,
    TResult Function(_AnimateSubtitle value)? animateSubtitle,
    TResult Function(_AnimateBody value)? animateBody,
    TResult Function(_AnimateDiscoverButton value)? animateDiscoverButton,
    required TResult orElse(),
  }) {
    if (animateBody != null) {
      return animateBody(this);
    }
    return orElse();
  }
}

abstract class _AnimateBody implements SplashEvent {
  const factory _AnimateBody() = _$_AnimateBody;
}

/// @nodoc
abstract class _$$_AnimateDiscoverButtonCopyWith<$Res> {
  factory _$$_AnimateDiscoverButtonCopyWith(_$_AnimateDiscoverButton value,
          $Res Function(_$_AnimateDiscoverButton) then) =
      __$$_AnimateDiscoverButtonCopyWithImpl<$Res>;
}

/// @nodoc
class __$$_AnimateDiscoverButtonCopyWithImpl<$Res>
    extends _$SplashEventCopyWithImpl<$Res>
    implements _$$_AnimateDiscoverButtonCopyWith<$Res> {
  __$$_AnimateDiscoverButtonCopyWithImpl(_$_AnimateDiscoverButton _value,
      $Res Function(_$_AnimateDiscoverButton) _then)
      : super(_value, (v) => _then(v as _$_AnimateDiscoverButton));

  @override
  _$_AnimateDiscoverButton get _value =>
      super._value as _$_AnimateDiscoverButton;
}

/// @nodoc

class _$_AnimateDiscoverButton implements _AnimateDiscoverButton {
  const _$_AnimateDiscoverButton();

  @override
  String toString() {
    return 'SplashEvent.animateDiscoverButton()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$_AnimateDiscoverButton);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() animateTitle,
    required TResult Function() animateSubtitle,
    required TResult Function() animateBody,
    required TResult Function() animateDiscoverButton,
  }) {
    return animateDiscoverButton();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? animateTitle,
    TResult Function()? animateSubtitle,
    TResult Function()? animateBody,
    TResult Function()? animateDiscoverButton,
  }) {
    return animateDiscoverButton?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? animateTitle,
    TResult Function()? animateSubtitle,
    TResult Function()? animateBody,
    TResult Function()? animateDiscoverButton,
    required TResult orElse(),
  }) {
    if (animateDiscoverButton != null) {
      return animateDiscoverButton();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_AnimateTitle value) animateTitle,
    required TResult Function(_AnimateSubtitle value) animateSubtitle,
    required TResult Function(_AnimateBody value) animateBody,
    required TResult Function(_AnimateDiscoverButton value)
        animateDiscoverButton,
  }) {
    return animateDiscoverButton(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_AnimateTitle value)? animateTitle,
    TResult Function(_AnimateSubtitle value)? animateSubtitle,
    TResult Function(_AnimateBody value)? animateBody,
    TResult Function(_AnimateDiscoverButton value)? animateDiscoverButton,
  }) {
    return animateDiscoverButton?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_AnimateTitle value)? animateTitle,
    TResult Function(_AnimateSubtitle value)? animateSubtitle,
    TResult Function(_AnimateBody value)? animateBody,
    TResult Function(_AnimateDiscoverButton value)? animateDiscoverButton,
    required TResult orElse(),
  }) {
    if (animateDiscoverButton != null) {
      return animateDiscoverButton(this);
    }
    return orElse();
  }
}

abstract class _AnimateDiscoverButton implements SplashEvent {
  const factory _AnimateDiscoverButton() = _$_AnimateDiscoverButton;
}

/// @nodoc
mixin _$SplashState {
  AnimationState get titleAnimationState => throw _privateConstructorUsedError;
  AnimationState get subtitleAnimationState =>
      throw _privateConstructorUsedError;
  AnimationState get bodyAnimationState => throw _privateConstructorUsedError;
  AnimationState get discoverButtonAnimationState =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $SplashStateCopyWith<SplashState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SplashStateCopyWith<$Res> {
  factory $SplashStateCopyWith(
          SplashState value, $Res Function(SplashState) then) =
      _$SplashStateCopyWithImpl<$Res>;
  $Res call(
      {AnimationState titleAnimationState,
      AnimationState subtitleAnimationState,
      AnimationState bodyAnimationState,
      AnimationState discoverButtonAnimationState});
}

/// @nodoc
class _$SplashStateCopyWithImpl<$Res> implements $SplashStateCopyWith<$Res> {
  _$SplashStateCopyWithImpl(this._value, this._then);

  final SplashState _value;
  // ignore: unused_field
  final $Res Function(SplashState) _then;

  @override
  $Res call({
    Object? titleAnimationState = freezed,
    Object? subtitleAnimationState = freezed,
    Object? bodyAnimationState = freezed,
    Object? discoverButtonAnimationState = freezed,
  }) {
    return _then(_value.copyWith(
      titleAnimationState: titleAnimationState == freezed
          ? _value.titleAnimationState
          : titleAnimationState // ignore: cast_nullable_to_non_nullable
              as AnimationState,
      subtitleAnimationState: subtitleAnimationState == freezed
          ? _value.subtitleAnimationState
          : subtitleAnimationState // ignore: cast_nullable_to_non_nullable
              as AnimationState,
      bodyAnimationState: bodyAnimationState == freezed
          ? _value.bodyAnimationState
          : bodyAnimationState // ignore: cast_nullable_to_non_nullable
              as AnimationState,
      discoverButtonAnimationState: discoverButtonAnimationState == freezed
          ? _value.discoverButtonAnimationState
          : discoverButtonAnimationState // ignore: cast_nullable_to_non_nullable
              as AnimationState,
    ));
  }
}

/// @nodoc
abstract class _$$_SplashStateCopyWith<$Res>
    implements $SplashStateCopyWith<$Res> {
  factory _$$_SplashStateCopyWith(
          _$_SplashState value, $Res Function(_$_SplashState) then) =
      __$$_SplashStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {AnimationState titleAnimationState,
      AnimationState subtitleAnimationState,
      AnimationState bodyAnimationState,
      AnimationState discoverButtonAnimationState});
}

/// @nodoc
class __$$_SplashStateCopyWithImpl<$Res> extends _$SplashStateCopyWithImpl<$Res>
    implements _$$_SplashStateCopyWith<$Res> {
  __$$_SplashStateCopyWithImpl(
      _$_SplashState _value, $Res Function(_$_SplashState) _then)
      : super(_value, (v) => _then(v as _$_SplashState));

  @override
  _$_SplashState get _value => super._value as _$_SplashState;

  @override
  $Res call({
    Object? titleAnimationState = freezed,
    Object? subtitleAnimationState = freezed,
    Object? bodyAnimationState = freezed,
    Object? discoverButtonAnimationState = freezed,
  }) {
    return _then(_$_SplashState(
      titleAnimationState: titleAnimationState == freezed
          ? _value.titleAnimationState
          : titleAnimationState // ignore: cast_nullable_to_non_nullable
              as AnimationState,
      subtitleAnimationState: subtitleAnimationState == freezed
          ? _value.subtitleAnimationState
          : subtitleAnimationState // ignore: cast_nullable_to_non_nullable
              as AnimationState,
      bodyAnimationState: bodyAnimationState == freezed
          ? _value.bodyAnimationState
          : bodyAnimationState // ignore: cast_nullable_to_non_nullable
              as AnimationState,
      discoverButtonAnimationState: discoverButtonAnimationState == freezed
          ? _value.discoverButtonAnimationState
          : discoverButtonAnimationState // ignore: cast_nullable_to_non_nullable
              as AnimationState,
    ));
  }
}

/// @nodoc

class _$_SplashState implements _SplashState {
  const _$_SplashState(
      {this.titleAnimationState = AnimationState.initial,
      this.subtitleAnimationState = AnimationState.initial,
      this.bodyAnimationState = AnimationState.initial,
      this.discoverButtonAnimationState = AnimationState.initial});

  @override
  @JsonKey()
  final AnimationState titleAnimationState;
  @override
  @JsonKey()
  final AnimationState subtitleAnimationState;
  @override
  @JsonKey()
  final AnimationState bodyAnimationState;
  @override
  @JsonKey()
  final AnimationState discoverButtonAnimationState;

  @override
  String toString() {
    return 'SplashState(titleAnimationState: $titleAnimationState, subtitleAnimationState: $subtitleAnimationState, bodyAnimationState: $bodyAnimationState, discoverButtonAnimationState: $discoverButtonAnimationState)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_SplashState &&
            const DeepCollectionEquality()
                .equals(other.titleAnimationState, titleAnimationState) &&
            const DeepCollectionEquality()
                .equals(other.subtitleAnimationState, subtitleAnimationState) &&
            const DeepCollectionEquality()
                .equals(other.bodyAnimationState, bodyAnimationState) &&
            const DeepCollectionEquality().equals(
                other.discoverButtonAnimationState,
                discoverButtonAnimationState));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(titleAnimationState),
      const DeepCollectionEquality().hash(subtitleAnimationState),
      const DeepCollectionEquality().hash(bodyAnimationState),
      const DeepCollectionEquality().hash(discoverButtonAnimationState));

  @JsonKey(ignore: true)
  @override
  _$$_SplashStateCopyWith<_$_SplashState> get copyWith =>
      __$$_SplashStateCopyWithImpl<_$_SplashState>(this, _$identity);
}

abstract class _SplashState implements SplashState {
  const factory _SplashState(
      {final AnimationState titleAnimationState,
      final AnimationState subtitleAnimationState,
      final AnimationState bodyAnimationState,
      final AnimationState discoverButtonAnimationState}) = _$_SplashState;

  @override
  AnimationState get titleAnimationState;
  @override
  AnimationState get subtitleAnimationState;
  @override
  AnimationState get bodyAnimationState;
  @override
  AnimationState get discoverButtonAnimationState;
  @override
  @JsonKey(ignore: true)
  _$$_SplashStateCopyWith<_$_SplashState> get copyWith =>
      throw _privateConstructorUsedError;
}
